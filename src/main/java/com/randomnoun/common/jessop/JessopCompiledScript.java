package com.randomnoun.common.jessop;

/* (c) 2016 randomnoun. All Rights Reserved. This work is licensed under a
 * BSD Simplified License. ( http://www.randomnoun.com/bsd-simplified.html ) 
 */

import java.io.PrintWriter;

import javax.script.Bindings;
import javax.script.Compilable;
import javax.script.CompiledScript;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptException;

/** Container class for the target script generated by the JessopScriptBuilder from the jessop source.
 * 
 * <p>If the implementation language supports compilation then this class also contains
 * the compiled form of the generated script.
 * 
 * @author knoxg
 */
public class JessopCompiledScript extends CompiledScript {

	
	/** target implementation engine (e.g. rhino, jython) */
	ScriptEngine engine;    
	
	/** generated script in target language */
	String source;         

	/** filename */
	String filename;         

	/** compiled target language source, if the implementation engine supports it */
	CompiledScript compiledSource;
	
	/** the JessopExceptionConverter to use to convert runtime exceptions */
	JessopExceptionConverter jec;
	
	/** the JessopBindingConverter to use to convert bindings for this engine */
	JessopBindingsConverter jbc;
	
	public JessopCompiledScript(ScriptEngine engine,
		boolean isCompileTarget,
		String filename, String source,
		JessopExceptionConverter jec,
		JessopBindingsConverter jbc) throws ScriptException {
		if (engine==null) { throw new NullPointerException("null engine"); }
		this.filename = filename;
		this.engine = engine;
		this.source = source;
		this.jec = jec;
		this.jbc = jbc;
		if (isCompileTarget && (engine instanceof Compilable)) {
			try {
				// could have another declaration to suppress compilation here
				// for rhino, the FILENAME needs to be defined at compilation time, not execution time
				if (filename!=null) {
					// this is the default context, not the context used at runtime
					ScriptContext defaultContext = engine.getContext();
					defaultContext.setAttribute(ScriptEngine.FILENAME, filename, ScriptContext.ENGINE_SCOPE);
					// this is the target engine, not the jessop engine
					engine.put(ScriptEngine.FILENAME, filename); 
				}
				this.compiledSource = ((Compilable) engine).compile(source);
			} catch (Error e) {
				// bsh says it implements Compilable, but then throws an 'unimplemented' Error.
				if ("unimplemented".equals(e.getMessage())) { 
					/* ignore */ 
				} else {
					throw e;
				}
			}
		}
	}

	/** {@inheritDoc} */
	@Override
	public Object eval(ScriptContext context) throws ScriptException {
		// NOTE TO FUTURE SELF
		// it is around this point that I think the rhino initStandardObjects() is called.
		// it's impossible to farging step through because I don't have the src for the oracle rhino impl.
		// what I would dearly love is to have it call initSafeStandardObjects() instead, so that
		// people can't escape the rhino sandbox. Is that too much to ask ? Is it ?
		// may be able to wrap this entire method in a ContextFactory.call() to set an alternate Context
		// see http://mozilla.github.io/rhino/javadoc/org/mozilla/javascript/ContextFactory.html#call(org.mozilla.javascript.ContextAction)
        // the rhino code is a intricate maze of twisty passages, all of which look alike.
		
		if (context==null) { 
			context = engine.getContext();
		} else {
			// some engines may require us to wrap/unwrap maps and lists to 
			// other data structures in order to treat them as native maps/dicts and arrays 
			// in that engine's language
			
			// may have to convert this context to whatever this engine expects (here's looking at you, lua)
			if (jbc!=null) {
				ScriptContext newContext = engine.getContext();
				Bindings gs = context.getBindings(ScriptContext.GLOBAL_SCOPE);
		        if (gs != null) {
		        	Bindings newGs = jbc.toScriptBindings(engine, newContext, gs, ScriptContext.GLOBAL_SCOPE); 
		            newContext.setBindings(newGs, ScriptContext.GLOBAL_SCOPE);
		        }
		        // this should transfer the filename for lua, but doesn't. Ah. filename may not be in the source context yet.
		        Bindings es = context.getBindings(ScriptContext.ENGINE_SCOPE);
		        Bindings newEs = jbc.toScriptBindings(engine, newContext, es, ScriptContext.ENGINE_SCOPE); 
	            newContext.setBindings(newEs, ScriptContext.ENGINE_SCOPE);
		        newContext.setReader(context.getReader());
		        newContext.setWriter(context.getWriter());
		        newContext.setErrorWriter(context.getErrorWriter());
		        context = newContext;
			} else {
				// see if the class changes
				// (could probably put this into a LuaBindingConverter instead now)
				
				ScriptContext newContext = engine.getContext();
				if (newContext.getClass().equals(context.getClass())) {
					// it's fine
				} else {
			        Bindings gs = context.getBindings(ScriptContext.GLOBAL_SCOPE);
			        if (gs != null) {
			            newContext.setBindings(gs, ScriptContext.GLOBAL_SCOPE);
			        }
			        // this should transfer the filename for lua, but doesn't. Ah. filename may not be in the source context yet.
		            newContext.setBindings(context.getBindings(ScriptContext.ENGINE_SCOPE), ScriptContext.ENGINE_SCOPE);
			        newContext.setReader(context.getReader());
			        newContext.setWriter(context.getWriter());
			        newContext.setErrorWriter(context.getErrorWriter());
			        context = newContext;
				}
			}
		}
		// get this from the jessop declaration eventually, but for now
		PrintWriter out;
		if (context.getWriter()==null) {  // jruby has a 'null' default writer
			out = new PrintWriter(System.out, true);
		} else {
			out = new PrintWriter(context.getWriter(), true);
		}
		context.setAttribute("out",  out, ScriptContext.ENGINE_SCOPE); // should be something like SCRIPT_SCOPE, really
		context.setAttribute(ScriptEngine.FILENAME,  filename, ScriptContext.ENGINE_SCOPE); // for engines that need this at runtime
		Object result;
		try {
			if (compiledSource!=null) {
				result = compiledSource.eval(context); // these throw LuaErrors instead of ScriptExceptions
			} else {
				result = engine.eval(source, context);
			}
		} catch (Throwable t) {
			if (jec==null) {
				throw t;
			} else {
				throw jec.toScriptException(context, t);
			}
		}
		out.flush();
		return result;
	}

	/** {@inheritDoc} */
	@Override
	public ScriptEngine getEngine() {
		return engine;
	}
	
	/** Return the generated source; can be used for debugging.
	 * 
	 * @return the generated source
	 */
	public String getSource() {
		return source;
	}

}