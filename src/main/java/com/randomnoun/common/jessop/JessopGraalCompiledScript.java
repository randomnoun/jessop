package com.randomnoun.common.jessop;

/* (c) 2016 randomnoun. All Rights Reserved. This work is licensed under a
 * BSD Simplified License. ( http://www.randomnoun.com/bsd-simplified.html ) 
 */

import java.io.PrintWriter;

import javax.script.Bindings;
import javax.script.Compilable;
import javax.script.CompiledScript;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptException;

import org.graalvm.polyglot.Context;
import org.graalvm.polyglot.Engine;
import org.graalvm.polyglot.HostAccess;
import org.graalvm.polyglot.PolyglotException;
import org.graalvm.polyglot.Source;
import org.graalvm.polyglot.SourceSection;
import org.graalvm.polyglot.Value;

/** Container class for the target script generated by the JessopScriptBuilder from the jessop source.
 * 
 * <p>Graalvm does provide a ScriptEngine interface, but it isn't as feature-complete as their Context/Engine interface, 
 * so this class wraps a Context/Engine script instead.
 * 
 * @author knoxg
 */
public class JessopGraalCompiledScript extends CompiledScript {

	
	/** target implementation engine (e.g. rhino, jython) */
	Engine engine;    
	
	/** generated script in target language */
	Source source;
	
	Value compiledSource;

	/** filename */
	String filename;         

	/** compiled target language source, if the implementation engine supports it */
	// CompiledScript compiledSource;
	
	/** the JessopExceptionConverter to use to convert runtime exceptions */
	JessopExceptionConverter jec;
	
	/** the JessopBindingConverter to use to convert bindings for this engine */
	JessopBindingsConverter jbc;
	

	// for graal context scripts
	public JessopGraalCompiledScript(Engine engine, String filename, Source source, Value compiledSource, boolean isCompileTarget, JessopExceptionConverter jec,
		JessopBindingsConverter jbc) 
	{
		this.filename = filename;
		this.engine = engine;
		this.source = source;
		this.compiledSource = compiledSource;
		this.jec = jec;
		this.jbc = jbc;

	}


	public JessopGraalCompiledScript(String language, boolean compileTarget, String filename2, String newScript,
			JessopExceptionConverter jec, JessopBindingsConverter jbc) throws ScriptException
	{

		Engine engine = Engine.newBuilder().option("engine.WarnInterpreterOnly", "false").build();
		HostAccess hostAccess = HostAccess.newBuilder(HostAccess.ALL) // would prefer to use EXPLICIT here, but then 'foreign-object-prototype' breaks
			.allowArrayAccess(true)
			.allowMapAccess(true)
			.build();                 
		Context context = Context.newBuilder("js")
			.engine(engine)
			.allowHostAccess(hostAccess)
			// .out()
			.option("js.foreign-object-prototype", "true") // so we can call .map() in javascript on java Lists
			.build();

		// Source source = Source.create("js", newScript);
		source = Source.newBuilder(language, newScript, filename).buildLiteral();
		
		
	    Value value;
	    try {
	         value = context.parse(source);
	         // parsing succeeded
	    } catch (PolyglotException e) {
	         if (e.isSyntaxError()) {
	             SourceSection location = e.getSourceLocation();
	             // syntax error detected at location
	         } else {
	             // other guest error detected
	         }
	         throw e; // @TODO wrap in ScriptException
	    }
	    
	}

	/** {@inheritDoc} */
	@Override
	public Object eval(ScriptContext context) throws ScriptException {

		// context is going to be null here, isn't it.
		// OR IS IT.
		
		
		// set up the context somehow
		
		// evaluate the parsed script
	    // Writer out = null; // @TODO setup
	    
	    // get this from the jessop declaration eventually, but for now
 		PrintWriter out;
 		if (context.getWriter()==null) {  // jruby has a 'null' default writer
 			out = new PrintWriter(System.out, true);
 		} else {
 			out = new PrintWriter(context.getWriter(), true);
 		}
 		context.setAttribute("out",  out, ScriptContext.ENGINE_SCOPE); // should be something like SCRIPT_SCOPE, really
 		context.setAttribute(ScriptEngine.FILENAME,  filename, ScriptContext.ENGINE_SCOPE); // for engines that need this at runtime
	 		
		
		Value result;
		try {
			result = compiledSource.execute();
			
		} catch (Throwable t) {
			if (jec == null) {
				throw t;
			} else {
				throw jec.toScriptException(context, t);
			}
		}
		out.flush();
		return result;
	}

	/** {@inheritDoc} */
	@Override
	public ScriptEngine getEngine() {
		// it's not a ScriptEngine
		return null;
	}
	
	/** Return the generated source; can be used for debugging.
	 * 
	 * @return the generated source
	 */
	public String getSource() {
		return source.toString(); // getCharacters().toString();
	}

}